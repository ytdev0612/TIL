## ex1 문자열을 입력으로 주면 문자열의 첫 글자와 마지막 글자를 출력하는 프로그램을 작성

```py
# 입력
# 입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 10)가 주어진다.
# 각 테스트 케이스는 한 줄에 하나의 문자열이 주어진다.
# 문자열은 알파벳 A~Z 대문자로 이루어지며 알파벳 사이에 공백은 없으며 문자열의 길이는 1000보다 작다.
#
# 출력
# 각 테스트 케이스에 대해서 주어진 문자열의 첫 글자와 마지막 글자를 연속하여 출력한다.
# 예제 입력 1
# 3
# ACDKJFOWIEGHE
# O
# AB
# 예제 출력 1
# AE
# OO
# AB

def solution(num):  # 1 <= num <= 10
    str_list = [input('문자열 입력 : ') for i in range(num)]
    # print(str_list)

    for i in str_list:
        print(i[0] + i[-1])


solution(3)
```


## ex2

```py
# S대학교 컴퓨터공학과 실습실 R912호에는 현재 N개의 창문이 있고 또 N명의 사람이 있다.
# 1번째 사람은 1의 배수 번째 창문을 열려 있으면 닫고 닫혀 있으면 연다.
# 2번째 사람은 2의 배수 번째 창문을 열려 있으면 닫고 닫혀 있으면 연다.
# 이러한 행동을 N번째 사람까지 진행한 후 열려 있는 창문의 개수를 구하라.
# 단, 처음에 모든 창문은 닫혀 있다.
# 예를 들어 현재 3개의 창문이 있고 3명의 사람이 있을 때,

# 1번째 사람은 1의 배수인 1,2,3번 창문을 연다. (1, 1, 1)
# 2번째 사람은 2의 배수인 2번 창문을 닫는다. (1, 0, 1)
# 3번째 사람은 3의 배수인 3번 창문을 닫는다. (1, 0, 0)
# 결과적으로 마지막에 열려 있는 창문의 개수는 1개 이다.

# 입력
# 첫 번째 줄에는 창문의 개수와 사람의 수 N(1 ≤ N ≤ 2,100,000,000)이 주어진다.
# 출력
# 마지막에 열려 있는 창문의 개수를 출력한다.

# 예제 입력 1
# 3
# 예제 출력 1
# 1
# 예제 입력 2
# 24
# 예제 출력 2
# 4
```
```py
def solution(n):    # n: 인원, 창문 수
    windows = [0 for i in range(n)]

    for i in range(1, n+1):
        for j in range(i, n + 1, i):
            if windows[j-1] == 0:
                windows[j-1] = 1
            else:
                windows[j-1] = 0

    return windows.count(1)

    
print(solution(24))

# 해당 방법은 n 값이 커지면 실행시간이 굉장히 오래걸리는 문제가 있음
# 창문의 상태-> 상태 변경 횟수가 홀수(약수가 홀수).
# 제곱근의 개수 25 입력 -> 5, n보다 작은 m제곱의 개수만큼 개수가 나온다.(m**2 <= n), n이 주어졌을 때 n까지의 제곱수의 개수(ex: 12 -> 3.xx... , 3개)
```


## ex3

```py
# 직선으로 되어있는 도로의 한 편에 가로수가 임의의 간격으로 심어져있다.
# KOI 시에서는 가로수들이 모두 같은 간격이 되도록 가로수를 추가로 심는 사업을 추진하고 있다.
# KOI 시에서는 예산문제로 가능한 한 가장 적은 수의 나무를 심고 싶다.
# 편의상 가로수의 위치는 기준점으로 부터 떨어져 있는 거리로 표현되며, 가로수의 위치는 모두 양의 정수이다.
# 예를 들어, 가로수가 (1, 3, 7, 13)의 위치에 있다면 (5, 9, 11)의 위치에 가로수를 더 심으면 모든 가로수들의 간격이 같게 된다.
# 또한, 가로수가 (2, 6, 12, 18)에 있다면 (4, 8, 10, 14, 16)에 가로수를 더 심어야 한다.
# 심어져 있는 가로수의 위치가 주어질 때, 모든 가로수가 같은 간격이 되도록 새로 심어야 하는 가로수의 최소수를 구하는 프로그램을 작성하라. 단, 추가되는 나무는 기존의 나무들 사이에만 심을 수 있다.

# 입력
# 첫째 줄에는 이미 심어져 있는 가로수의 수를 나타내는 하나의 정수 N이 주어진다(3 ≤ N ≤ 100,000).
# 둘째 줄부터 N개의 줄에는 각 줄마다 심어져 있는 가로수의 위치가 양의 정수로 주어지며,
# 가로수의 위치를 나타내는 정수는 1,000,000,000 이하이다.
# 가로수의 위치를 나타내는 정수는 모두 다르고, N개의 가로수는 기준점으로부터 떨어진 거리가 가까운 순서대로 주어진다.
# 출력
# 모든 가로수가 같은 간격이 되도록 새로 심어야 하는 가로수의 최소수를 첫 번째 줄에 출력한다.

# 예제 입력 1
# 4
# 1
# 3
# 7
# 13
# 예제 출력 1
# 3
#
#
# 예제 입력 2
# 4
# 2
# 6
# 12
# 18
# 예제 출력 2
# 5
```

```py
def solution(num):  # 이미 심어져있는 나무의 수
    trees = [int(input('심어진 나무 위치 입력 : ')) for i in range(num)]
    # print(trees)
    trees.sort()
    # print(trees)
    check = [trees[i+1]-trees[i] for i in range(len(trees)-1)]
    check.sort()
    # print(check)

    # trees : 나무가 심어진 위치 정렬
    # check : 나무들 사이의 거리를 구해서 정렬

    # a = check[0]
    # b = check[1]
    # while b != 0:
    #     a, b = b, a % b     # a : 가장 짧은 길이 2개의 최대공약수, 문제 예시가 답이 나오는 방법이라 나왔을 뿐 부정확
    def u(a, b):
        while b != 0:
            a, b = b, a % b
        return a

    ex1 = check[0]
    for i in range(1, len(check)):
        ex1 = u(ex1, check[i])

    res = sum(1 for i in range(trees[0], trees[-1]+1, ex1) if i not in trees)
    print(res)

solution(4)

# 간격에 대해서 최대공약수 구해야 되는데 지금 방식은 부정확
# 모든 간격에 대해서 최대공약수 구해야 될거 같다
```